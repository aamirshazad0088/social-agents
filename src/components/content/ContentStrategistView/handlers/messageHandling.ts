import { Message } from '../types';
import { ContentThread } from '@/services/database/threadService.client';
import { BusinessInfo } from '@/types/businessInfo.types';

export interface SendMessageParams {
    message: string;
    threadId: string;
    attachedFiles?: Array<{
        type: 'image' | 'file';
        name: string;
        url: string;
        size: number;
    }>;
    businessContext?: BusinessInfo;
    modelId?: string;
}

export interface SendMessageResult {
    response: string;
    contentGenerated?: boolean;
    generatedContent?: any;
    readyToGenerate?: boolean;
    parameters?: any;
    generatedImage?: string;
    generatedVideo?: string;
    isGeneratingMedia?: boolean;
}

/**
 * Convert frontend AttachedFile to API AttachmentInput format
 */
function convertToAttachmentFormat(files: SendMessageParams['attachedFiles']): Array<{
    type: 'image' | 'pdf' | 'docx' | 'pptx' | 'document' | 'text' | 'csv' | 'json';
    name: string;
    data: string;
    mimeType?: string;
    size?: number;
}> | undefined {
    if (!files || files.length === 0) return undefined;

    return files.map(file => {
        // Detect file type from name and mime type
        let type: 'image' | 'pdf' | 'docx' | 'pptx' | 'document' | 'text' | 'csv' | 'json' = 'document';
        let mimeType: string | undefined;
        
        const fileName = file.name.toLowerCase();
        
        // Detect mime type from data URL
        if (file.url.startsWith('data:')) {
            const mimeMatch = file.url.match(/^data:([^;]+);/);
            if (mimeMatch) {
                mimeType = mimeMatch[1];
            }
        }
        
        if (file.type === 'image' || fileName.match(/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico|tiff|heic|heif)$/)) {
            type = 'image';
        } else if (fileName.endsWith('.pdf')) {
            type = 'pdf';
        } else if (fileName.endsWith('.docx') || fileName.endsWith('.doc')) {
            type = 'docx';
        } else if (fileName.endsWith('.pptx') || fileName.endsWith('.ppt')) {
            type = 'pptx';
        } else if (fileName.endsWith('.csv')) {
            type = 'csv';
        } else if (fileName.endsWith('.json')) {
            type = 'json';
        } else if (fileName.endsWith('.txt') || fileName.endsWith('.md')) {
            type = 'text';
        }


        return {
            type,
            name: file.name,
            data: file.url, // base64 data URL
            mimeType,
            size: file.size,
        };
    });
}

export const sendMessage = async (params: SendMessageParams): Promise<SendMessageResult> => {
    const attachments = convertToAttachmentFormat(params.attachedFiles);


    const response = await fetch('/api/ai/content/strategist/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: params.message,
            threadId: params.threadId,
            attachments,
            businessContext: params.businessContext,
            modelId: params.modelId,
        })
    });

    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to get response');
    }

    return await response.json();
};

export const handleMessageResult = (
    result: SendMessageResult,
    setMessages: React.Dispatch<React.SetStateAction<Message[]>>
): boolean => {
    const aiResponse = result?.response;
    let shouldCreateThread = false;

    // Check if content was generated by the agent
    if (result?.contentGenerated && result?.generatedContent) {
        // Just show the AI response, don't create post automatically
        setMessages(prev => [...prev, {
            role: 'model',
            content: aiResponse,
        }]);
        shouldCreateThread = true;
    } 
    // Check if ready to generate (show parameters for confirmation)
    else if (result?.readyToGenerate && result?.parameters) {
        setMessages(prev => [...prev, {
            role: 'model',
            content: aiResponse,
            parameters: result.parameters,
        }]);
        shouldCreateThread = true;
    } else {
        // Regular conversation response
        const newMessage: Message = { 
            role: 'model', 
            content: aiResponse 
        };
        
        // Check if AI response includes generated media URLs
        if (result?.generatedImage) {
            newMessage.generatedImage = result.generatedImage;
        }
        if (result?.generatedVideo) {
            newMessage.generatedVideo = result.generatedVideo;
        }
        if (result?.isGeneratingMedia) {
            newMessage.isGeneratingMedia = true;
        }
        
        setMessages(prev => [...prev, newMessage]);
        shouldCreateThread = true;
    }

    return shouldCreateThread;
};

export const formatErrorMessage = (err: any): string => {
    const errorMessage = err instanceof Error ? err.message : String(err);
    
    // API Key / Authentication errors
    if (errorMessage.includes('API_KEY') || errorMessage.includes('401') || errorMessage.includes('Unauthorized') || errorMessage.includes('API key')) {
        return 'üîë API key not configured or invalid. Please check your API settings.';
    }
    
    // Rate limit / Quota errors
    if (errorMessage.includes('429') || errorMessage.includes('rate') || errorMessage.includes('quota') || errorMessage.includes('insufficient') || errorMessage.includes('Rate limit')) {
        return '‚è≥ Rate limit or quota exceeded. Please wait a moment or try a different model.';
    }
    
    // Model not found / unavailable
    if (errorMessage.includes('Model not allowed') || (errorMessage.includes('model') && (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('unexpected')))) {
        return 'ü§ñ Selected model is unavailable. Please try a different model.';
    }
    
    // Bad request / Invalid format
    if (errorMessage.includes('400') || errorMessage.includes('Bad Request') || errorMessage.includes('Invalid')) {
        return '‚ùå Invalid request. Please check your input and try again.';
    }
    
    // Module / Service errors
    if (errorMessage.includes('MODULE_NOT_FOUND') || errorMessage.includes('Cannot find module')) {
        return 'üîß Service temporarily unavailable. Please try again later.';
    }
    
    // Network / Connection errors
    if (errorMessage.includes('fetch') || errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED') || err.code === 'ERR_NETWORK') {
        return 'üåê Connection error. Please check your internet connection.';
    }
    
    // Timeout errors
    if (err.code === 'ECONNABORTED' || errorMessage.includes('timeout') || errorMessage.includes('ETIMEDOUT')) {
        return '‚è±Ô∏è Request timed out. Please try again.';
    }
    
    // Server errors
    if (errorMessage.includes('500') || errorMessage.includes('502') || errorMessage.includes('503') || errorMessage.includes('Internal Server')) {
        return 'üîß Server error. Please try again in a few seconds.';
    }
    
    // Generic fallback
    return '‚ùå Something went wrong. Please try again.';
};
